1. Write a Simple program which takes input of your name and then greets you with a random keyword out of "Hello, Hi, Namaskar, Good day, How are you?" Make use of following cmdlets only

Read-host, Write-Output, Get-Random

$name = read-host "What is your name"
$Greeting = ("Hello", "Hi", "Namaskar", "Good day", "How are you?")
Write-Output "$($Greeting | Get-Random) $name"



2. Write a one-liner which extracts the phone number from the given string
My phone number # 2 is +1-45466-3443-22


"My phone number # 2 is +1-45466-3443-22" | Select-String -Pattern "\+\d{1}-\d{5}-\d{4}-\d{2}"


3. Write a one-liner that converts a string to uppercase and replaces all spaces with underscores. For example, “Hello World” should become “HELLO_WORLD”.


4. Write a one-liner or code which extracts the various tests and their results from dcdiag output

$dcdiag | select-String -Pattern "\. (.*) \b(passed|failed)\b test (.*)" | %{ [pscustomobject]@{Entity=$_.matches.groups[1].value;Result=$_.matches.groups[2].value;TestName=$_.matches.groups[3].value }}

5. Write a one-liner which find the top 5 processes taking memory, shows their name, Starttime and Memory used in MB
Get-process | Sort-object WorkingSet64 -Descending | Select-Object Name, StartTime, @{l="MemoryinMB";e={"{0:N2}" -f ($_.WorkingSet64/1MB)}} -First 5

6. Write a one-liner that counts the number of words in a text file. For example, if the file contains “This is a test file”, the output should be 5. You can use Get-Content, Measure-Object like cmdlets

Get-content C:\temp\sam.txt | Measure-Object -Word

7. Write a function that takes a mandatory parameter named URL and returns the status code and content type of the web page. Make use of Invoke-WebRequest cmdlet and select-object cmdlet.

function Get-WebPageInfo($URL) {
    param ([Parameter(Mandatory=$true)][string]$URL)
    $response = Invoke-WebRequest -Uri $URL
    $info = $response | Select-Object -Property StatusCode, ContentType
    return $info
}
Get-WebPageInfo "https://www.bing.com"


8. Write a function, which takes a mandatory parameter named Number and returns true if the number is prime otherwise returns false. Make use of if else and normal operators only.

function IsPrime {
	Param([parameter(mandatory=$True)][validatescript({If($_ -gt 0 -AND $_ -lt 10000){$true} else {throw "$_ is not valid, input an integer betweek 1-10000"}})][int]$Number)
	if($Number -le 1) {return $false }# 1 is neither composite nor prime
	for($i=2;$i -lt $number;$i++){	if($number % $i -eq 0){ return $false}}
	return $true
}

9. Write a function, which takes a mandatory parameter named Number and returns prime factors of the same.

function Get-PrimeFactors{
    param ([Parameter(Mandatory=$true)][int]$Number)
    $factors = @();$divisor = 2
    while ($Number -gt 1) {  
	if ($Number % $divisor -eq 0) {     $factors += $divisor; $Number = $Number / $divisor   }
        else {            $divisor++        }    }
    return ($factors -join " x ")}



10. Write a function that generates a random password with 4-80 characters, including at least one uppercase letter, one lowercase letter, one digit, and one symbol. Make use of Get-Random cmdlet and -InputObject parameter.

function Get-RandomPassword{
	param ([Parameter(Mandatory=$true)][validatescript({$_ -ge 4 -and $_ -le 80})][int]$Count)

	$rest = ""	
	$upper = Get-Random -InputObject ([char[]]"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
	$lower = Get-Random -InputObject ([char[]]"abcdefghijklmnopqrstuvwxyz")
	$digit = Get-Random -InputObject ([char[]]"0123456789")
	$symbol = Get-Random -InputObject ([char[]]"!@#$%^&*()_+-=")
	if($count - 4 -gt 0){$rest = (Get-Random -InputObject ([char[]]"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=") -count ($count - 4) ) -join ""	}
	$randomPassword = (($upper , $rest , $lower , $symbol , $digit) | get-random -Count 5) -join ""

    return $RandomPassword
}


11. Write a function, which takes servers as input (one or more) and provides disk space details (computername, volumename, size in gb and free space in gb)

function Get-DiskSpace {
    Param([parameter(mandatory=$True)]$servers)
	ForEach ($Server in $Servers) {
		Get-WmiObject -Class Win32_logicaldisk -computer $Server | Select-object PSComputername, VolumeName, DeviceID, @{Name = "SizeGB"; Expression = { $_.Size / 1GB -as [int] } }, @{Name = "UsedGB"; Expression = { "{0:N2}" -f (($_.Size - $_.Freespace) / 1GB) } }, @{Name = "FreeGB"; Expression = { "{0:N2}" -f ($_.FreeSpace / 1GB) } }
	}
}

12. Write a function, which takes a mandatory parameter named path, checks if the path is valid before running the function and then returns object with Foldername, FolderPath, Size, SubfolderCount, FileCount. Make use of Get-ChildItem cmdlet and -recurse parameters.


function Get-FolderSize {
    Param([parameter(mandatory=$True)][validatescript({if(Test-Path $_){$true} else {throw "$_ is not valid path"}})]$Path)
    $folders = Get-ChildItem -Path $Path -Directory -force
    foreach ($folder in $folders) {
        $folderPath = $folder.FullName
        $folderName = $folder.Name
        $subfolders = Get-ChildItem -Path $folderPath -Directory -Recurse
        $files = Get-ChildItem -Path $folderPath -File -Recurse -force
        $size = "{0:N2}" -f (($files | Measure-Object -Property Length -Sum).Sum/1gb)
        $fileCount = $files.Count
        $subfolderCount = $subfolders.Count

        [PSCustomObject]@{
            FolderName = $folderName
            FolderPath = $folderPath
            Size = $size
            SubfoldersCount = $subfolderCount
            FileCount = $fileCount
        }
    }
}
$folderPath = "C:\"
Get-FolderSize -Path $folderPath



13. Add progress bar in the folder size function, use Write-progress with parameters like activity, status, currentoperation and percentComplete

function Get-FolderSize {
    Param([parameter(mandatory=$True)][validatescript({if(Test-Path $_){$true} else {throw "$_ is not valid path"}})]$Path)
    $folders = Get-ChildItem -Path $Path -Directory -force -erroraction SilentlyContinue
    $count = $folders.count	
    $i = 0
    foreach ($folder in $folders) {	
	Write-Progress -Activity "Getting details of folders in $($path)" -Status "$("{0:N2}" -f ($i * 100 / $count)) % complete" -CurrentOperation "Working on $($folder.Fullname)" -PercentComplete (($i / $count) * 100)
	$i++
        $folderPath = $folder.FullName
        $folderName = $folder.Name
        $subfolders = Get-ChildItem -Path $folderPath -Directory -Recurse -force -erroraction SilentlyContinue
        $files = Get-ChildItem -Path $folderPath -File -Recurse -force -erroraction SilentlyContinue
        $size = "{0:N2}" -f (($files | Measure-Object -Property Length -Sum).Sum/1gb)
        $fileCount = $files.Count
        $subfolderCount = $subfolders.Count

        [PSCustomObject]@{
            FolderName = $folderName
            FolderPath = $folderPath
            Size = $size
            SubfoldersCount = $subfolderCount
            FileCount = $fileCount
        }
    }
}


14. Write a code, which generates a html report for top 10 processes running in the system by memory usages in MB.

$header = @"
<style>
    body { background-color: #b9d7f7; }  
    table { font-size: 12px; border: 1px;  font-family: Arial, Helvetica, sans-serif; }  
    td { padding: 4px; margin: 0px; border: 1; } 
    th { background: #395870; color: #fff; font-size: 11px; vertical-align: middle; }
</style>
"@
 
 
$htmlParams = @{
      Title = "Processes details"
      Body = Get-Date
      PreContent = "<P>Generated by Corporate IT</P>"
      PostContent = "For details, contact Corporate IT.“
      Head = $header
    }
    get-process | Sort-Object WorkingSet64 -Descending |Select-Object Name, Id, PriorityClass, @{l="Memory";e={$("{0:N2}" -f ($_.WorkingSet64/1Mb))+ " Mb"}} -First 10 | ConvertTo-Html @htmlParams | Out-File Processes.htm
    Invoke-Item Processes.htm

Get-process | Sort-Object WorkingSet64 -Descending |Select-Object Name, Id, PriorityClass, @{l="Memory";e={$("{0:N2}" -f ($_.WorkingSet64/1Mb))+ " Mb"}} -First 10 | ConvertTo-Html -Title "Processes details" -PreContent "<p><b>Generated by Corporate IT</b></p>" -PostContent "<br><b>For details contact Corporate IT</b></br>" -Body (get-date) | Out-File Processes.htm


15. Write a function, which takes mandatory parameters like Source, Logname, EventId, message and logs an event in event view as per given details

Function Write-CustomEvent {
    Param(  [Parameter(Mandatory = $True)]$LogName,
            [Parameter(Mandatory = $True)]$Source,
            [Parameter(Mandatory = $True)][int]$Eventid,
            [Parameter(ValueFromPipeline = $true, mandatory = $false)][ValidateSet('“Information”', 'Error', 'Warning')]$EntryType = "Information",
            [Parameter(Mandatory = $True)]$message
    )
    Try {
        New-EventLog -LogName $Logname -Source $Source –ErrorAction SilentlyContinue
    } catch {}
    Write-EventLog –LogName $logname –Source $Source –EntryType $EntryType –EventId $EventId –message $message
}
